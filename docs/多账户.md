# OpenClawWeChat 多账户配置设计

## 概述

当需要对接多个独立的 apiKey（多个 bot/小程序实例）时，插件支持多账户模式。每个账户拥有独立的 apiKey、轮询任务和会话上下文。

## SessionKey 规则

### 单账户（1 个 apiKey）

- **默认 sessionKey**：`agent:main:main`
- 与历史配置完全兼容，用户无需修改

### 多账户（2 个及以上 apiKey）

- **第一个账户（default）**：可使用 `agent:main:main`，或显式配置
- **第二个及后续账户**：**必须**显式配置 `sessionKey`
- 原因：每个 apiKey 对应独立 bot，会话需隔离，避免不同 bot 的历史混在一起

## 配置示例

### 单账户（兼容旧格式）

```json
{
  "plugins": {
    "entries": {
      "openclawwechat": {
        "enabled": true,
        "config": {
          "apiKey": "20231227:secret1",
          "pollIntervalMs": 2000,
          "debug": false
        }
      }
    }
  }
}
```

- 等价于账户 `default`，sessionKey 为 `agent:main:main`

### 多账户

```json
{
  "plugins": {
    "entries": {
      "openclawwechat": {
        "enabled": true,
        "defaults": {
          "pollIntervalMs": 2000,
          "debug": false
        },
        "accounts": {
          "default": {
            "apiKey": "20231227:secret1"
          },
          "bot2": {
            "apiKey": "20231228:secret2",
            "sessionKey": "agent:main:wechat:bot2"
          },
          "enterprise": {
            "apiKey": "20231229:secret3",
            "sessionKey": "agent:main:wechat:enterprise",
            "pollIntervalMs": 3000
          }
        }
      }
    }
  }
}
```

说明：

- `default`：可不配 sessionKey，使用 `agent:main:main`
- `bot2`、`enterprise`：**必须**配置 `sessionKey`，且彼此不重复

### 配置字段说明

| 字段 | 层级 | 类型 | 必填 | 说明 |
|------|------|------|------|------|
| `enabled` | 插件根 | boolean | - | 是否启用，默认 true |
| `defaults` | 插件根 | object | - | 各账户的默认值 |
| `defaults.pollIntervalMs` | - | number | - | 轮询间隔（毫秒），默认 2000 |
| `defaults.debug` | - | boolean | - | 调试日志，默认 false |
| `config` | 插件根 | object | - | **单账户兼容**：存在且无 accounts 时作为 default |
| `config.apiKey` | - | string | ✅ | API Key，格式 `bot_id:secret` |
| `accounts` | 插件根 | object | - | 多账户定义 |
| `accounts.<id>.apiKey` | - | string | ✅ | 该账户的 API Key |
| `accounts.<id>.sessionKey` | - | string | 多账户时必填* | Session Key，格式 `agent:<agentId>:<rest>` |
| `accounts.<id>.pollIntervalMs` | - | number | - | 覆盖 defaults |
| `accounts.<id>.debug` | - | boolean | - | 覆盖 defaults |
| `accounts.<id>.enabled` | - | boolean | - | 是否启用，默认 true；`false` 时禁用该账户 |

\* 当 `accounts` 存在且账户数 ≥ 2 时，除 `default` 外的账户必须配置 `sessionKey`。

## SessionKey 格式要求

- OpenClaw 要求：`agent:<agentId>:<rest>`，至少 3 段
- 建议：`agent:main:wechat:<accountId>`，便于区分来源
- 多账户时各账户的 sessionKey 必须唯一

## 数据流

```
账户 default (apiKey: K1, sessionKey: agent:main:main)
  └─ 轮询 /botK1/getUpdates → 注入消息 → 记录到 agent:main:main 会话

账户 bot2 (apiKey: K2, sessionKey: agent:main:wechat:bot2)
  └─ 轮询 /botK2/getUpdates → 注入消息 → 记录到 agent:main:wechat:bot2 会话
```

同一用户在不同 bot 下拥有独立会话，互不共享历史。

---

## 升级兼容：旧配置文件

插件升级后，**无需修改现有配置**即可继续使用。解析逻辑如下。

### 兼容规则

| 配置形态 | 解析结果 |
|----------|----------|
| 仅有 `config`，无 `accounts` | 视为单账户，`listAccountIds` = `["default"]`，`resolveAccount("default")` 从 `config` 读取 |
| 有 `accounts` | 多账户模式，`listAccountIds` = `Object.keys(accounts)` |
| 同时存在 `config` 和 `accounts` | `accounts` 优先；若 `accounts` 中有 `default` 则用其覆盖，否则用 `config` 补充 `default` |

### 旧配置自动映射

旧格式（单账户），位于 `plugins.entries.openclawwechat`：

```json
{
  "plugins": {
    "entries": {
      "openclawwechat": {
        "enabled": true,
        "config": {
          "apiKey": "20231227:secret1",
          "pollIntervalMs": 2000,
          "sessionKey": "agent:main:main",
          "debug": false
        }
      }
    }
  }
}
```

解析为：

- 账户 ID：`default`
- apiKey：`config.apiKey`
- pollIntervalMs：`config.pollIntervalMs` ?? 2000
- sessionKey：`config.sessionKey` ?? `agent:main:main`（旧版 `sessionKeyPrefix` 已弃用，若存在则兼容解析）
- debug：`config.debug` ?? false

### 升级后行为

- **不修改配置**：继续作为单账户运行，sessionKey 默认 `agent:main:main`，与升级前一致
- **迁移到多账户**：在 `accounts` 中新增账户，保留或删除 `config` 均可；若有 `config` 且无 `accounts.default`，则自动生成 `default` 账户

---

## 单账户是否有必要修改配置？

**不需要。** 单账户时保持原有 `config` 格式即可，升级后自动识别。

```
原有配置（config）  →  解析为  →  账户 default（apiKey、pollIntervalMs、sessionKey、debug 等均从 config 读取）
```

无需改为 `accounts.default`，也无需添加 `defaults` 或 `accounts` 字段。

---

## 多账户时原配置选项如何处理？

原 `config` 中的 `apiKey`、`pollIntervalMs`、`sessionKey`、`debug` 迁移到多账户结构时，对应关系如下。

### 1. 方案 A：config 作为 default 账户来源（推荐）

保留 `config`，多账户时由 `config` 生成 `default` 账户，其他账户写在 `accounts` 中：

```json
{
  "plugins": {
    "entries": {
      "openclawwechat": {
        "enabled": true,
        "config": {
          "apiKey": "20231227:secret1",
          "pollIntervalMs": 2000,
          "debug": false
        },
        "accounts": {
          "bot2": {
            "apiKey": "20231228:secret2",
            "sessionKey": "agent:main:wechat:bot2"
          }
        }
      }
    }
  }
}
```

- **default**：来自 `config`，`pollIntervalMs`、`debug` 使用 config 中的值
- **bot2**：仅写 `apiKey` 和 `sessionKey`，`pollIntervalMs`、`debug` 使用代码默认值（或来自 `defaults`）

### 2. 方案 B：全部迁移到 accounts，用 defaults 继承

删除 `config`，所有账户在 `accounts` 中定义，公共选项放到 `defaults`：

```json
{
  "plugins": {
    "entries": {
      "openclawwechat": {
        "enabled": true,
        "defaults": {
          "pollIntervalMs": 2000,
          "debug": false
        },
        "accounts": {
          "default": {
            "apiKey": "20231227:secret1"
          },
          "bot2": {
            "apiKey": "20231228:secret2",
            "sessionKey": "agent:main:wechat:bot2"
          }
        }
      }
    }
  }
}
```

- **default**：继承 `defaults`，仅需写 `apiKey`
- **bot2**：继承 `defaults`，需写 `apiKey`、`sessionKey`；要覆盖时可在本账户写 `pollIntervalMs`、`debug`

### 3. 原配置选项对应表

| 原 config 字段 | 单账户 | 多账户（方案 A） | 多账户（方案 B） |
|----------------|--------|------------------|------------------|
| `apiKey` | 直接使用 | config 作为 default 的 apiKey | 写入 `accounts.default.apiKey` |
| `pollIntervalMs` | 直接使用 | config 作为 default 的值 | 写入 `defaults` 或各账户 |
| `sessionKey` | 直接使用 | default 用 `agent:main:main` | default 不配，用默认 |
| `debug` | 直接使用 | config 作为 default 的值 | 写入 `defaults` 或各账户 |

### 4. 小结

| 场景 | 是否需改配置 | 说明 |
|------|--------------|------|
| 单账户，升级后继续单账户 | **否** | 继续使用 `config`，无需改动 |
| 单账户 → 多账户 | **是** | 新增 `accounts`，原 `config` 可保留作为 default，或迁移到 `accounts.default` + `defaults` |

---

## 可行性评估

### 结论：**可行，改动量适中**

### 1. OpenClaw 框架支持

| 能力 | 支持情况 |
|------|----------|
| 多账户列举 | ✅ `listAccountIds(cfg)` 返回账户列表 |
| 按账户解析配置 | ✅ `resolveAccount(cfg, accountId)` 按 accountId 返回配置 |
| 按账户启动 | ✅ Gateway 对每个 accountId 单独调用 `startAccount` |
| 账户级 enabled | ✅ `isAccountEnabled(account)` 支持 |
| 账户级 configured | ✅ `isConfigured(account)` 支持 |

**依据**：`openclaw/src/gateway/server-channels.ts` 第 104–159 行，对 `listAccountIds` 的每个 id 调用 `resolveAccount` 和 `startAccount`。

### 2. 插件改动清单

| 模块 | 改动 | 复杂度 |
|------|------|--------|
| **config.ts** | 新增 `getPluginConfig(cfg, accountId?)`、`listAccountIds(cfg)`、解析 `accounts` / `defaults` / 兼容 `config` | 中 |
| **channel.ts** | `listAccountIds` 从配置动态返回；`resolveAccount` 按 accountId 从 accounts/config 解析 | 中 |
| **session.ts** | `resolveSession` 接收 accountId/accountConfig，按账户取 sessionKey | 低 |
| **message-injector.ts** | 已有 accountId，传入 resolveSession；无需改 | 低 |
| **polling.ts** | `ctx.account` 已包含 account 配置，无改动 | 无 |
| **reply-sender / channel outbound** | 已有 accountId、cfg，按账户取 apiKey，无改动 | 无 |
| **openclaw.plugin.json** | 扩展 configSchema 支持 accounts、defaults | 低 |
| **scripts/config-init.js** | 支持单账户/多账户模式选择，多账户时可添加多个账户 | 低 |

### 3. 后端前提

- **ClawChat 中转服务**需支持：按 apiKey 区分消息队列，`/bot{apiKey}/getUpdates` 仅返回该 apiKey 的消息。
- 若后端已按 apiKey 路由（每个小程序实例独立 apiKey），则无需改造。

### 4. 风险与注意点

| 风险 | 缓解 |
|------|------|
| 配置解析错误 | 兼容规则清晰，单账户保持原逻辑 |
| sessionKey 冲突 | 多账户时强制第二账户起显式配置，启动可做唯一性校验 |
| 账户数过多 | 每账户一轮询，N 账户 ≈ N 个定时器，通常可接受 |
| 旧配置不兼容 | 有 config 无 accounts 时视为单账户，零迁移 |

### 5. 预估工作量

- **开发**：约 4–6 天（含配置解析、兼容、单测）
  - config.ts 重写：4-6 小时
  - session.ts 重写：2-3 小时
  - channel.ts 改造：3-4 小时
  - polling.ts 重写：6-8 小时（最复杂）
  - reply-sender.ts 改造：2-3 小时
  - openclaw.plugin.json 扩展：1-2 小时
  - config-init.js 改造：1-2 小时
  - 单元测试：4-6 小时
- **测试**：单账户回归、双账户联调、三账户压力、配置迁移验证（1-2 天）
- **文档**：补充实现说明、迁移指南、测试场景（1-2 天）

**总估计**：6-10 天

---

## 任务拆分

将多账户实现拆分为可独立交付的子任务，按依赖顺序执行。

### 任务一览

| 阶段 | 任务 | 依赖 | 预估 | 产出 |
|------|------|------|------|------|
| 1 | T1：配置与 schema | - | 2h | config.ts、openclaw.plugin.json |
| 2 | T2：channel 多账户接口 | T1 | 2h | listAccountIds、resolveAccount |
| 3 | T3：session 按账户解析 | T1 | 2h | resolveSession(accountId, accountConfig) |
| 4 | T4：Offset 管理 | - | 2h | 数据结构 + 持久化 |
| 5 | T5：轮询服务重构 | T2,T3,T4 | 6h | 多账户并发轮询 |
| 6 | T6：reply-sender / outbound 适配 | T2 | 2h | 按 accountId 选择 apiKey |
| 7 | T7：配置校验与启动验证 | T1 | 2h | 单账户/多账户校验 |
| 8 | T11：初始化脚本改造 | T1 | 1-2h | config-init.js 支持单/多账户 |
| 9 | T8：单元测试 | T1-T7,T11 | 4h | 单测覆盖 |
| 10 | T9：集成与回归测试 | T8 | 1-2d | 测试报告 |
| 11 | T10：文档更新 | T9 | 1d | 迁移指南、故障排查 |

---

### T1：配置与 schema（约 2h）

**目标**：支持单/多账户配置解析，扩展 configSchema。

**改动文件**：
- `src/config.ts`
- `openclaw.plugin.json`

**交付物**：
- [ ] `getPluginConfig(cfg, accountId?)`：按 accountId 返回解析后配置
- [ ] `listAccountIds(cfg)`：返回账户 ID 列表，过滤 `enabled: false`
- [ ] 解析 `accounts`、`defaults`、兼容 `config`（有 config 无 accounts → 单账户 default）
- [ ] configSchema 增加 `accounts`、`defaults`、`accounts.<id>.enabled`

---

### T2：channel 多账户接口（约 2h，依赖 T1）

**目标**：实现 Gateway 所需的 `listAccountIds`、`resolveAccount`。

**改动文件**：
- `src/channel.ts`

**交付物**：
- [ ] `listAccountIds(cfg)`：从配置动态返回，调用 config 层
- [ ] `resolveAccount(cfg, accountId)`：返回 `WeChatMiniprogramAccount`，含 accountId、apiKey、sessionKey 等

---

### T3：session 按账户解析（约 2h，依赖 T1）

**目标**：`resolveSession` 支持多账户，按 accountConfig 取 sessionKey。

**改动文件**：
- `src/session.ts`

**交付物**：
- [ ] `resolveSession({ cfg, accountId, accountConfig, openid, runtime })`
- [ ] sessionKey 优先来自 accountConfig，fallback 到 `agent:main:main`
- [ ] message-injector 调用时传入 accountId / accountConfig（若已有则无改动）

---

### T4：Offset 管理（约 2h，可并行 T1）

**目标**：每账户独立 offset，支持持久化。

**改动文件**：
- `src/polling.ts`（或新建 `src/offset.ts`）

**交付物**：
- [ ] `Map<accountId, AccountOffset>` 数据结构
- [ ] `loadOffsetsFromFile(stateDir)`、`saveOffsetsToFile(stateDir, offsets)`
- [ ] 轮询成功后更新 offset，下次请求携带

---

### T5：轮询服务重构（约 6h，依赖 T2,T3,T4）

**目标**：按账户并发轮询，错误隔离。

**改动文件**：
- `src/polling.ts`

**交付物**：
- [ ] 为每个 accountId 启动独立轮询（`startAccount` 调用时）
- [ ] 从 resolveAccount 取 apiKey、pollIntervalMs
- [ ] 使用 T4 的 offset，轮询 URL 含 `offset`
- [ ] 单账户错误不影响其他账户（错误计数、可选退避）
- [ ] 支持 `enabled: false` 的账户不启动轮询

---

### T6：reply-sender / outbound 适配（约 2h，依赖 T2）

**目标**：回复消息时按 accountId 选择 apiKey。

**改动文件**：
- `src/reply-sender.ts`
- `src/channel.ts`（outbound 部分，如需要）

**交付物**：
- [ ] 回复时根据消息来源（accountId）取对应 apiKey
- [ ] 目标地址格式不变（`openclawwechat:openid`）

---

### T7：配置校验与启动验证（约 2h，依赖 T1）

**目标**：启动时校验配置，多账户时非 default 必须 sessionKey。

**改动文件**：
- `src/config.ts` 或 `src/channel.ts`

**交付物**：
- [ ] 单账户：apiKey 必填
- [ ] 多账户：每个账户 apiKey 必填，非 default 的 sessionKey 必填且不重复
- [ ] 启动失败时明确报错信息

---

### T11：初始化脚本改造（约 1-2h，依赖 T1）

**目标**：`config-init.js` 支持单账户与多账户配置初始化。

**改动文件**：
- `scripts/config-init.js`

**交付物**：
- [ ] 启动时询问「单账户 / 多账户」
- [ ] 单账户：保持现有流程，写入 `config`（兼容旧格式）
- [ ] 多账户：引导添加多个账户，每个账户输入 apiKey、sessionKey（非 default 必填）
- [ ] `getPluginConfig` 兼容读取 `config` 与 `accounts`
- [ ] `setPluginConfig` 支持写入 `accounts` 或 `config`（按模式选择）
- [ ] 已有配置时，支持「新增账户」「删除账户」「切回单账户」等操作（可选，简化版可仅支持初始化）

---

### T8：单元测试（约 4h，依赖 T1-T7,T11）

**目标**：核心逻辑单测。

**交付物**：
- [ ] `getPluginConfig` / `listAccountIds` 单账户、多账户、accounts+config 混合
- [ ] `resolveSession` 多账户 sessionKey
- [ ] offset 加载/保存、轮询更新
- [ ] 配置校验逻辑

---

### T9：集成与回归测试（约 1-2 天，依赖 T8）

**目标**：端到端验证。

**交付物**：
- [ ] 单账户回归：与现有行为一致
- [ ] 双账户联调：两账户独立轮询、独立回复
- [ ] 配置迁移：旧 config → 新 accounts 无功能损失
- [ ] 错误隔离：一账户异常不影响其他账户
- [ ] config-init.js：单账户/多账户初始化流程可正常完成并生效

---

### T10：文档更新（约 1 天，依赖 T9）

**目标**：补充实现说明与运维文档。

**交付物**：
- [ ] 多账户配置示例（与本文档对齐）
- [ ] 迁移指南、回滚步骤
- [ ] 故障排查（sessionKey 冲突、offset 异常等）
- [ ] 版本更新说明（v1.0.12 → v1.1.0）
- [ ] config-init.js 使用说明（单账户/多账户模式）

---

### 执行顺序建议

```
T1 (config) ──┬── T2 (channel) ── T6 (reply-sender)
              │
              ├── T3 (session)
              │
              ├── T7 (验证)
              │
              └── T11 (config-init.js)
              │
T4 (offset) ──┴── T5 (polling)

T8 (单测) 依赖 T1-T7,T11
T9 (集成) 依赖 T8
T10 (文档) 依赖 T9
```

- **并行**：T1 与 T4 可同时进行；T2、T3、T7、T11 均依赖 T1，完成 T1 后可并行推进。
- **串行**：T5 完成后再做 T8 集成测试。

---

## Offset 管理

### 设计目标

每个账户独立维护 `offset`，避免重复获取已处理的消息。

### 数据结构

```typescript
/**
 * 账户 Offset 管理
 */
interface AccountOffset {
  accountId: string;    // 账户 ID（如 "default", "bot2"）
  offset: number;        // 当前轮询 offset
  lastPollAt: number;  // 上次轮询时间（用于调试）
  errorCount: number;    // 连续错误计数（用于错误隔离）
}

/**
 * 全局 Offset 存储
 */
const offsets = new Map<string, AccountOffset>();

// 初始化
accounts.forEach(account => {
  offsets.set(account.accountId, {
    accountId: account.accountId,
    offset: 0,
    lastPollAt: Date.now(),
    errorCount: 0,
  });
});
```

### 轮询时更新 Offset

```typescript
// polling.ts 中的轮询函数
const poll = async (account: PollingAccount) => {
  const offsetKey = account.accountId;
  const offsetState = offsets.get(offsetKey);

  const pollUrl = `${BRIDGE_URL}/bot${account.apiKey}/getUpdates?offset=${offsetState?.offset || 0}&limit=100&timeout=1`;

  const response = await fetch(pollUrl);
  const data = await response.json();

  // 处理消息...
  if (data.result && data.result.length > 0) {
    const updates = data.result;

    // 找到最大的 update_id
    let maxUpdateId = 0;
    for (const update of updates) {
      if (update.update_id > maxUpdateId) {
        maxUpdateId = update.update_id;
      }
    }

    // 更新 offset
    const newOffset = maxUpdateId + 1;
    offsets.set(offsetKey, {
      ...offsetState!,
      offset: newOffset,
      lastPollAt: Date.now(),
      errorCount: 0,  // 成功时重置错误计数
    });

    // 标记消息为已处理
    await markProcessed(account, updates);
  }
};
```

### Offset 持久化（可选）

> **注意**：插件运行在 Node.js 环境，使用文件系统持久化，而非 localStorage。

```typescript
import fs from 'node:fs';
import path from 'node:path';

/**
 * 从文件加载 Offset（路径：~/.openclaw/state/openclawwechat-offsets.json）
 */
function loadOffsetsFromFile(stateDir: string): Map<string, number> {
  const filePath = path.join(stateDir, 'openclawwechat-offsets.json');
  try {
    const data = fs.readFileSync(filePath, 'utf-8');
    const parsed = JSON.parse(data);
    return new Map(Object.entries(parsed));
  } catch {
    return new Map();
  }
}

/**
 * 保存 Offset 到文件
 */
function saveOffsetsToFile(stateDir: string, offsets: Map<string, number>): void {
  const filePath = path.join(stateDir, 'openclawwechat-offsets.json');
  fs.writeFileSync(filePath, JSON.stringify(Object.fromEntries(offsets)), 'utf-8');
}

// 在轮询服务启动时加载（stateDir 来自 runtime.state.resolveStateDir()）
const stateDir = runtime.state.resolveStateDir();
const storedOffsets = loadOffsetsFromFile(stateDir);
accounts.forEach(account => {
  const savedOffset = storedOffsets.get(account.accountId);
  offsets.set(account.accountId, {
    accountId: account.accountId,
    offset: savedOffset ?? 0,
    lastPollAt: Date.now(),
    errorCount: 0,
  });
});

// 定期保存（避免频繁写入）
setInterval(() => {
  const toSave = new Map<string, number>();
  offsets.forEach((value, key) => {
    toSave.set(key, value.offset);
  });
  saveOffsetsToFile(stateDir, toSave);
}, 60000); // 每分钟保存一次
```

---

## 并发轮询控制

### 设计目标

支持多账户并发轮询，同时控制总并发数，避免服务器过载。

### 策略 1：完全并发（默认）

```typescript
/**
 * 完全并发模式：所有账户同时轮询
 */
interface PollingWorker {
  accountId: string;
  account: AccountConfig;
  timer: NodeJS.Timeout;
  running: boolean;
}

const workers: Map<string, PollingWorker> = new Map();

// 启动所有账户的轮询
function startAllAccounts(accounts: AccountConfig[]): void {
  accounts.forEach(account => {
    const worker = {
      accountId: account.accountId,
      account,
      timer: null as any,
      running: false,
    };
    workers.set(account.accountId, worker);

    // 立即启动轮询
    schedulePoll(worker);
  });
}

// 调度轮询任务
function schedulePoll(worker: PollingWorker): void {
  if (worker.running) return;
  worker.running = true;

  pollAccount(worker.account).finally(() => {
    worker.running = false;
    // 设置下一次轮询
    worker.timer = setTimeout(() => schedulePoll(worker), worker.account.config.pollIntervalMs);
  });
}
```

### 策略 2：交错并发（推荐）

```typescript
/**
 * 交错并发模式：账户轮询时间分散，避免同时请求
 */
function startStaggeredPolling(accounts: AccountConfig[]): void {
  accounts.forEach((account, index) => {
    const worker = {
      accountId: account.accountId,
      account,
      timer: null as any,
      running: false,
    };
    workers.set(account.accountId, worker);

    // 交错启动：每个账户延迟启动
    const staggerDelay = index * 500; // 每个账户延迟 500ms
    setTimeout(() => schedulePoll(worker), staggerDelay);
  });
}
```

### 策略 3：限流并发（高并发场景）

```typescript
/**
 * 限流并发模式：同时最多 N 个请求
 */
const MAX_CONCURRENT = 5; // 最多 5 个并发请求
let activePolls = 0;
const pendingQueue: PollingWorker[] = [];

function schedulePollWithLimit(worker: PollingWorker): void {
  if (activePolls >= MAX_CONCURRENT) {
    // 队列等待
    pendingQueue.push(worker);
    return;
  }

  // 执行轮询
  activePolls++;
  pollAccount(worker.account)
    .finally(() => {
      activePolls--;

      // 处理队列中的下一个
      if (pendingQueue.length > 0) {
        const next = pendingQueue.shift()!;
        schedulePollWithLimit(next);
      }
    })
    .then(() => {
      // 成功后继续下一次轮询
      worker.timer = setTimeout(() => schedulePollWithLimit(worker), worker.account.config.pollIntervalMs);
    });
}
```

### 轮询性能影响

| 账户数 | 并发策略 | 定时器数量 | CPU 占用 | 网络峰值 |
|---------|----------|------------|---------|---------|
| 1-3 | 完全并发 | 1-3 个 | 低 | 高（同时） |
| 4-10 | 交错并发 | 4-10 个 | 中 | 中（分散） |
| 10+ | 限流并发 | N 个（队列） | 中-高 | 低（受控） |

---

## 错误隔离策略

### 设计目标

一个账户失败不影响其他账户继续轮询，错误账户自动重试。

### 错误分类处理

```typescript
/**
 * 错误类型
 */
enum ErrorType {
  NetworkError = 'network',      // 网络错误（DNS、超时等）
  AuthError = 'auth',          // 认证错误（401、403）
  RateLimit = 'ratelimit',      // 限流错误（429）
  ServerError = 'server',        // 服务器错误（500、502、503）
  ParseError = 'parse',          // 解析错误（JSON 格式错误）
}

/**
 * 错误处理策略
 */
interface ErrorStrategy {
  type: ErrorType;
  maxRetries: number;           // 最大重试次数
  backoffMs: number;           // 退避时间（毫秒）
  shouldStopAccount: boolean;   // 是否停止该账户
}

const ERROR_STRATEGIES: Record<ErrorType, ErrorStrategy> = {
  [ErrorType.NetworkError]: {
    type: ErrorType.NetworkError,
    maxRetries: 5,
    backoffMs: 5000,    // 5 秒后重试
    shouldStopAccount: false,
  },
  [ErrorType.AuthError]: {
    type: ErrorType.AuthError,
    maxRetries: 0,       // 不重试，停止账户
    backoffMs: 0,
    shouldStopAccount: true,
  },
  [ErrorType.RateLimit]: {
    type: ErrorType.RateLimit,
    maxRetries: 3,
    backoffMs: 60000,   // 1 分钟后重试
    shouldStopAccount: false,
  },
  [ErrorType.ServerError]: {
    type: ErrorType.ServerError,
    maxRetries: 3,
    backoffMs: 10000,   // 10 秒后重试
    shouldStopAccount: false,
  },
  [ErrorType.ParseError]: {
    type: ErrorType.ParseError,
    maxRetries: 1,
    backoffMs: 2000,
    shouldStopAccount: false,
  },
};

/**
 * 错误处理
 */
async function handlePollError(
  account: PollingAccount,
  error: Error,
  errorType: ErrorType,
  log?: any
): Promise<void> {
  const strategy = ERROR_STRATEGIES[errorType];
  const offsetKey = account.accountId;
  const offsetState = offsets.get(offsetKey);

  // 增加错误计数
  offsetState!.errorCount++;

  log?.error?.(
    `[${account.accountId}] Polling error (${errorType}): ${error.message}, ` +
    `retry ${offsetState!.errorCount}/${strategy.maxRetries}`
  );

  // 判断是否应停止账户
  if (offsetState!.errorCount >= strategy.maxRetries || strategy.shouldStopAccount) {
    log?.warn?.(`[${account.accountId}] Stopping polling due to ${errorType}`);

    // 停止该账户的定时器
    const worker = workers.get(account.accountId);
    if (worker?.timer) {
      clearTimeout(worker.timer);
      worker.timer = null;
    }
    worker!.running = false;

    return;
  }

  // 设置退避重试
  const backoffTime = strategy.backoffMs * offsetState!.errorCount;
  const worker = workers.get(account.accountId);
  worker!.timer = setTimeout(
    () => pollAccount(account),
    backoffTime
  );
}

/**
 * 错误类型识别
 */
function classifyError(error: any): ErrorType {
  if (error.response) {
    const status = error.response.status;

    if (status === 401 || status === 403) {
      return ErrorType.AuthError;
    }
    if (status === 429) {
      return ErrorType.RateLimit;
    }
    if (status >= 500) {
      return ErrorType.ServerError;
    }
  }

  if (error.message?.includes('fetch failed') || error.message?.includes('ECONNREFUSED')) {
    return ErrorType.NetworkError;
  }

  if (error.message?.includes('JSON')) {
    return ErrorType.ParseError;
  }

  return ErrorType.NetworkError; // 默认
}
```

### 健康检查机制

```typescript
/**
 * 定期健康检查
 */
setInterval(async () => {
  workers.forEach((worker, accountId) => {
    // 检查是否超过 5 分钟无响应
    const lastPoll = offsets.get(accountId)?.lastPollAt || 0;
    const now = Date.now();

    if (now - lastPoll > 5 * 60 * 1000 && worker.running) {
      log?.warn?.(`[${accountId}] Polling stall detected, restarting`);

      // 重启轮询
      if (worker.timer) {
        clearTimeout(worker.timer);
      }
      worker.running = false;
      schedulePoll(worker);
    }
  });
}, 60000); // 每分钟检查一次
```

---

## 回复消息时的账户选择

### 问题场景

用户通过不同的 API Key 发送消息，OpenClaw 生成回复时需要选择正确的账户发送。

### 解决方案：消息携带账户标识

```typescript
/**
 * 扩展消息上下文，携带账户信息
 */
export interface MessageWithAccount extends MessageToInject {
  accountId?: string;        // 新增：来源账户 ID
  botId?: number;           // 新增：Bot ID
  apiKey?: string;          // 新增：API Key（可选，用于快速定位）
}

/**
 * 修改 message-injector.ts
 */
export async function injectMessage(
  message: MessageWithAccount,  // 扩展接口
  config: InjectConfig,
  log?: any
): Promise<void> {
  // 保存账户信息到运行时上下文
  runtime.channel.session.setMessageContext({
    updateId: message.updateId,
    accountId: message.accountId || config.accountId,
    botId: message.botId,
    timestamp: Date.now(),
  });

  // ... 其余注入逻辑
}
```

### 发送回复时选择账户

```typescript
/**
 * 修改 reply-sender.ts，支持账户选择
 */
export interface ReplyConfigWithAccount extends ReplyConfig {
  accountId?: string;  // 新增：目标账户 ID
}

export async function sendReply(
  payload: { text?: string; mediaUrls?: string[]; mediaUrl?: string; mediaTypes?: string[] },
  openid: string,
  updateId: number | undefined,
  config: ReplyConfigWithAccount,  // 扩展接口
  accountId: string,  // 保留原有参数
  log?: { error?: (msg: string) => void }
): Promise<void> {
  // 获取运行时上下文中的账户信息
  const messageContext = runtime.channel.session.getMessageContext(updateId);

  // 优先使用消息上下文中的账户
  const targetAccountId = config.accountId || messageContext?.accountId || accountId;

  // 根据账户 ID 获取对应的 apiKey 和 sessionKey
  const targetAccount = resolveAccountById(targetAccountId);
  if (!targetAccount) {
    throw new Error(`Account not found: ${targetAccountId}`);
  }

  // 使用目标账户的 apiKey 和 sessionKey 发送
  await sendReplyInternal(
    payload,
    openid,
    updateId,
    {
      ...config,
      apiKey: targetAccount.apiKey,
      bridgeUrl: BRIDGE_URL,
    },
    targetAccountId,
    log
  );
}

/**
 * 根据账户 ID 解析配置
 */
function resolveAccountById(accountId: string): AccountConfig | undefined {
  const cfg = getPluginConfig();

  // 多账户模式
  if (cfg.accounts) {
    if (accountId === 'default' && !cfg.accounts.default) {
      // default 账户从 config 读取
      return {
        accountId,
        apiKey: cfg.apiKey,
        pollIntervalMs: cfg.pollIntervalMs,
        sessionKey: cfg.sessionKey || DEFAULT_CONFIG.sessionKey,
        debug: cfg.debug ?? DEFAULT_CONFIG.debug,
      };
    }
    return cfg.accounts[accountId];
  }

  // 单账户模式
  if (cfg.apiKey) {
    return {
      accountId: 'default',
      apiKey: cfg.apiKey,
      pollIntervalMs: cfg.pollIntervalMs,
      sessionKey: cfg.sessionKey || DEFAULT_CONFIG.sessionKey,
      debug: cfg.debug ?? DEFAULT_CONFIG.debug,
    };
  }

  return undefined;
}
```

### 账户信息缓存

```typescript
/**
 * 账户信息缓存（避免重复解析配置）
 */
interface AccountCache {
  [accountId: string]: {
    account: AccountConfig;
    timestamp: number;
  };
}

const accountCache: AccountCache = {};
const CACHE_TTL = 60000; // 1 分钟缓存

/**
 * 带缓存的账户解析
 */
function resolveAccountWithCache(accountId: string): AccountConfig | undefined {
  const cached = accountCache[accountId];
  const now = Date.now();

  // 缓存命中
  if (cached && (now - cached.timestamp) < CACHE_TTL) {
    return cached.account;
  }

  // 解析配置
  const account = resolveAccountById(accountId);
  if (!account) return undefined;

  // 更新缓存
  accountCache[accountId] = {
    account,
    timestamp: now,
  };

  return account;
}
```

---

## 配置验证逻辑

### 单账户验证

```typescript
/**
 * 验证单账户配置
 */
function validateSingleAccount(cfg: PluginConfig): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // 检查 apiKey
  if (!cfg.apiKey?.trim()) {
    errors.push('apiKey is required');
  } else if (!cfg.apiKey.includes(':')) {
    errors.push('apiKey must be in format "bot_id:secret"');
  }

  // 检查 sessionKey 格式
  if (cfg.sessionKey && !isValidSessionKeyFormat(cfg.sessionKey)) {
    errors.push('sessionKey must be in format "agent:<agentId>:<rest>" (at least 3 parts)');
  }

  // 检查 pollIntervalMs
  if (cfg.pollIntervalMs && (cfg.pollIntervalMs < 500 || cfg.pollIntervalMs > 60000)) {
    errors.push('pollIntervalMs must be between 500 and 60000');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
```

### 多账户验证

```typescript
/**
 * 验证多账户配置
 */
function validateMultiAccounts(cfg: MultiAccountPluginConfig): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // 检查是否有 accounts
  if (!cfg.accounts || Object.keys(cfg.accounts).length === 0) {
    errors.push('accounts object is required for multi-account mode');
    return { valid: false, errors };
  }

  const accountIds = Object.keys(cfg.accounts);

  // 检查每个账户
  accountIds.forEach((accountId, index) => {
    const account = cfg.accounts![accountId];
    const prefix = accountId === 'default' ? 'Default' : `Account "${accountId}"`;

    // 检查 apiKey
    if (!account.apiKey?.trim()) {
      errors.push(`${prefix}: apiKey is required`);
    } else if (!account.apiKey.includes(':')) {
      errors.push(`${prefix}: apiKey must be in format "bot_id:secret"`);
    }

    // 非 default 账户必须配置 sessionKey
    if (accountId !== 'default' && !account.sessionKey?.trim()) {
      errors.push(`${prefix}: sessionKey is required for non-default accounts`);
    }

    // 检查 sessionKey 格式
    if (account.sessionKey && !isValidSessionKeyFormat(account.sessionKey)) {
      errors.push(`${prefix}: sessionKey must be in format "agent:<agentId>:<rest>"`);
    }

    // 检查 pollIntervalMs
    if (account.pollIntervalMs && (account.pollIntervalMs < 500 || account.pollIntervalMs > 60000)) {
      errors.push(`${prefix}: pollIntervalMs must be between 500 and 60000`);
    }

    // 检查 debug
    if (account.debug !== undefined && typeof account.debug !== 'boolean') {
      errors.push(`${prefix}: debug must be a boolean`);
    }
  });

  // 检查 sessionKey 唯一性
  const sessionKeys = accountIds
    .map(id => cfg.accounts![id].sessionKey)
    .filter(key => key !== undefined && key !== null);

  const uniqueSessionKeys = new Set(sessionKeys);
  if (uniqueSessionKeys.size !== sessionKeys.length) {
    errors.push(`sessionKeys must be unique across all accounts (duplicates found)`);
  }

  // 检查 default 账户
  if (accountIds.includes('default')) {
    const defaultAccount = cfg.accounts!.default;

    // default 可以不配 sessionKey（使用默认值）
    if (defaultAccount.sessionKey !== undefined && !isValidSessionKeyFormat(defaultAccount.sessionKey)) {
      errors.push(`Default account: sessionKey format invalid`);
    }
  }

  // 如果有 config.apiKey 且有 accounts.default，给出警告（不是错误）
  if (cfg.apiKey && cfg.accounts?.default) {
    // 两者都存在，accounts.default 优先
    // 这是文档中定义的行为，不算错误
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * 统一配置验证入口
 */
export function validatePluginConfig(cfg: any): {
  valid: boolean;
  errors: string[];
} {
  const pluginConfig = cfg?.plugins?.entries?.openclawwechat || {};

  // 判断是单账户还是多账户模式
  if (pluginConfig.accounts && Object.keys(pluginConfig.accounts).length > 0) {
    return validateMultiAccounts(pluginConfig as any);
  }

  // 检查是否有 config（单账户模式）
  if (!pluginConfig.config) {
    return {
      valid: false,
      errors: ['Either "config" (single-account) or "accounts" (multi-account) is required'],
    };
  }

  return validateSingleAccount(pluginConfig.config as any);
}
```

### 启动时验证

```typescript
/**
 * channel.ts 的 startAccount 实现
 */
startAccount: async (ctx) => {
  const { account } = ctx;

  // 验证配置
  const validation = validatePluginConfig(ctx.deps?.config);
  if (!validation.valid) {
    const errorMsg = `Configuration validation failed:\n${validation.errors.join('\n')}`;
    ctx.log?.error?.(`[${account.accountId}] ${errorMsg}`);
    throw new Error(errorMsg);
  }

  ctx.log?.info?.(`[${account.accountId}] Configuration validated successfully`);

  // 继续启动逻辑
  return await startPollingService(ctx);
}
```

---

## Session 迁移指南

### 场景 1：单账户迁移到多账户

**步骤**：

1. **备份当前配置**
   ```json
   {
     "plugins": {
       "entries": {
         "openclawwechat": {
           "enabled": true,
           "config": {
             "apiKey": "20231227:secret1",
             "pollIntervalMs": 2000,
             "sessionKey": "agent:main:main"
           }
         }
       }
     }
   }
   ```

2. **修改配置结构（推荐方案 A）**
   ```json
   {
     "plugins": {
       "entries": {
         "openclawwechat": {
           "enabled": true,
           "config": {
             "apiKey": "20231227:secret1",
             "pollIntervalMs": 2000,
             "sessionKey": "agent:main:main"
           },
           "accounts": {
             "bot2": {
               "apiKey": "20231228:secret2",
               "sessionKey": "agent:main:wechat:bot2"
             }
           }
         }
       }
     }
   }
   ```

3. **重启插件验证**
   - 检查日志：应显示两个账户启动成功
   - 测试 bot1 的轮询和发送
   - 测试 bot2 的轮询和发送

### 场景 2：多账户新增账户

**步骤**：

1. **在 `plugins.entries.openclawwechat.accounts` 中新增**
   ```json
   "accounts": {
     "default": { "apiKey": "20231227:secret1" },
     "bot2": {
       "apiKey": "20231228:secret2",
       "sessionKey": "agent:main:wechat:bot2"
     },
     "bot3": {
       "apiKey": "20231229:secret3",
       "sessionKey": "agent:main:wechat:bot3"
     }
   }
   ```

2. **热重载（无需重启）**
   - OpenClaw 检测到配置变更会自动重新加载
   - 新账户立即开始轮询

### 场景 3：删除账户

**步骤**：

1. **从 `plugins.entries.openclawwechat.accounts` 中删除对应条目**
   ```json
   "accounts": {
     "default": { "apiKey": "20231227:secret1" },
     "bot3": { "apiKey": "20231229:secret3", "sessionKey": "agent:main:wechat:bot3" }
   }
   ```

2. **清理资源**
   - 停止该账户的轮询定时器
   - 清理该账户的 offset（可选）
   - 通知用户账户已停止

### 迁移验证清单

- [ ] 配置格式正确（JSON 语法）
- [ ] 所有账户都有 apiKey
- [ ] 非 default 账户都有 sessionKey
- [ ] sessionKey 格式符合 `agent:<agentId>:<rest>`
- [ ] sessionKey 唯一不重复
- [ ] 轮询间隔合理（500-60000ms）
- [ ] 重启后所有账户正常运行
- [ ] 每个账户能独立发送和接收消息
- [ ] offset 独立维护不混乱
- [ ] 错误隔离（一个失败不影响其他）

---

## 性能影响评估

### CPU 占用

| 账户数 | 单账户 CPU | 多账户 CPU | 增量 |
|---------|-----------|-----------|-------|
| 1 | ~2% | - | - |
| 2 | ~2% | ~4% | +100% |
| 5 | ~2% | ~8% | +300% |
| 10 | ~2% | ~12% | +500% |

**说明**：假设每个轮询占用 ~2% CPU（含网络 I/O 等待）

### 内存占用

| 账户数 | 单账户内存 | 多账户内存 | 主要来源 |
|---------|-----------|-----------|---------|
| 1 | ~50MB | - | Runtime + 单个 offset |
| 2 | ~50MB | ~55MB | 额外 offset map + 工作器 |
| 5 | ~50MB | ~70MB | N 个 offset + 定时器 |
| 10 | ~50MB | ~95MB | N 个 offset + 缓存 |

**说明**：每个账户约增加 4-5MB（offset + 上下文）

### 网络请求

| 账户数 | 单账户 QPS | 多账户 QPS | 请求间隔 |
|---------|-----------|-----------|---------|
| 1 | 0.5 | - | 每 2 秒 |
| 2 | 0.5 | 1.0 | 每 1 秒（交错） |
| 5 | 0.5 | 2.5 | 每 400ms（交错） |
| 10 | 0.5 | 5.0 | 每 200ms（交错） |

**说明**：
- 假设每个账户 pollIntervalMs = 2000ms
- 交错策略：延迟启动 = index × 200ms
- 实际 QPS = 账户数 / (轮询间隔 / 交错延迟)

### 优化建议

1. **限制账户数**：建议不超过 10 个账户
   - CPU 增量可控制在 +500%
   - 内存占用可控（<100MB）
   - 网络压力适中（<10 QPS）

2. **使用交错并发**：
   - 避免同时请求造成的瞬时峰值
   - 降低服务器压力

3. **定期清理资源**：
   - 清理长时间不活跃的 Session
   - 定期保存 offset 到持久化

4. **监控关键指标**：
   - 每个账户的轮询成功率
   - 每个账户的平均延迟
   - 错误率和类型分布

---

## 测试场景

### 单账户回归测试

| 测试用例 | 步骤 | 预期结果 |
|---------|------|---------|
| 单账户轮询 | 1. 配置单账户 2. 等待消息 3. 验证成功注入 | 消息正确注入 |
| 单账户发送文本 | 1. 发送文本消息 2. 验证后端接收 | 消息正确发送 |
| 单账户发送媒体 | 1. 发送图片/视频 2. 验证后端接收 | 媒体正确上传 |
| 单账户会话连续性 | 1. 发送多条消息 2. 验证历史完整 | 会话历史连续 |

### 多账户联调测试

| 测试用例 | 步骤 | 预期结果 |
|---------|------|---------|
| 双账户独立轮询 | 1. 配置 2 个账户 2. 验证各自独立获取消息 | 每个账户独立获取 |
| 双账户独立发送 | 1. 分别用不同账户发送 2. 验证消息隔离 | 消息通过正确的 apiKey 发送 |
| 跨账户会话隔离 | 1. 账户 A 发送消息 2. 账户 B 查看历史 | B 看不到 A 的历史 |
| offset 独立性 | 1. 账户 A 获取消息 2. 账户 B 轮询 | B 不受 A offset 影响 |
| sessionKey 隔离性 | 1. 检查两个账户的 Session Key 2. 确认不共享 | Session 完全独立 |

### 错误隔离测试

| 测试用例 | 步骤 | 预期结果 |
|---------|------|---------|
| 单账户失败不影响其他 | 1. 配置 2 个账户 2. 停止账户 1 的 apiKey 3. 验证账户 2 继续运行 | 账户 2 正常轮询 |
| 网络错误自动重试 | 1. 断开网络 2. 触发轮询 3. 验证重试逻辑 | 按策略退避重试 |
| 认证错误停止账户 | 1. 配置错误 apiKey 2. 触发轮询 3. 验证停止 | 账户停止并记录错误 |
| 限流错误降级 | 1. 模拟 429 响应 2. 触发轮询 3. 验证退避时间 | 延迟 1 分钟后重试 |

### 配置迁移测试

| 测试用例 | 步骤 | 预期结果 |
|---------|------|---------|
| 旧配置自动识别 | 1. 使用旧格式配置 2. 重启插件 3. 验证行为 | 按单账户模式运行 |
| 迁移到多账户 | 1. 修改为多账户格式 2. 重启插件 3. 验证行为 | 按多账户模式运行 |
| 单账户回退 | 1. 删除 accounts 字段 2. 重启插件 3. 验证行为 | 按单账户模式运行 |
| 配置错误提示 | 1. 配置无效 sessionKey 2. 重启插件 3. 验证错误信息 | 清晰的错误提示 |

### 压力测试

| 测试用例 | 配置 | 持续时间 | 预期结果 |
|---------|------|---------|---------|
| 5 账户并发轮询 | 5 个账户 | 1 小时 | CPU <10%，无崩溃 |
| 10 账户并发轮询 | 10 个账户 | 1 小时 | CPU <15%，内存 <100MB |
| 高频率轮询 | 轮询间隔 500ms | 30 分钟 | 无请求超时，无明显延迟 |

### 长期稳定性测试

| 测试用例 | 配置 | 持续时间 | 验证点 |
|---------|------|---------|--------|
| 内存泄漏检测 | 10 个账户 | 24 小时 | 内存占用稳定，无持续增长 |
| Offset 持久化 | 10 个账户 | 24 小时 | 重启后 offset 正确恢复 |
| 自动恢复机制 | 10 个账户 | 24 小时 | 错误后自动恢复，无人工干预 |

---

## 回滚方案

### 快速回滚：删除 accounts 字段

**场景**：多账户出现问题需要快速回退到单账户

**步骤**：

1. **编辑配置文件**
   ```json
   {
     "plugins": {
       "entries": {
         "openclawwechat": {
           "enabled": true,
           "config": {
             "apiKey": "20231227:secret1",
             "pollIntervalMs": 2000,
             "sessionKey": "agent:main:main"
           }
         }
       }
     }
   }
   ```
   （删除 `accounts` 字段，仅保留 `config`）

2. **重启插件**
   - OpenClaw 自动重载配置
   - 按单账户模式运行

**验证**：
- [ ] 插件正常启动
- [ ] 只有一个账户（default）
- [ ] 轮询正常工作
- [ ] 消息发送正常

### 渐进回滚：保留 accounts 但禁用

**场景**：逐步测试，想保留多账户配置但暂时只用一个

**步骤**：

1. **禁用不需要的账户**
   ```json
   {
     "plugins": {
       "entries": {
         "openclawwechat": {
           "config": { "apiKey": "20231227:secret1", ... },
           "accounts": {
             "default": { "apiKey": "20231227:secret1", ... },
             "bot2": {
               "apiKey": "20231228:secret2",
               "sessionKey": "agent:main:wechat:bot2",
               "enabled": false
             }
           }
         }
       }
     }
   }
   ```
   （使用 `enabled: false` 禁用该账户，与 OpenClaw 惯例一致）

2. **修改代码支持 enabled 标记**
   ```typescript
   // 过滤被禁用的账户
   const ids = Object.entries(pluginConfig.accounts)
     .filter(([, acc]) => acc.enabled !== false)
     .map(([id]) => id);
   ```

3. **验证**
   - bot2 账户不启动
   - default 账户正常工作
   - 配置仍然保留，方便重新启用

### 配置备份和恢复

**备份方案**：

```bash
# Linux/Mac
cp openclaw.config.json openclaw.config.backup.$(date +%Y%m%d_%H%M%S).json

# Windows
copy openclaw.config.json openclaw.config.backup.%date%.json
```

**恢复方案**：

```bash
# 恢复最近备份
cp openclaw.config.backup.20260221_100000.json openclaw.config.json

# 或使用版本控制
git checkout HEAD~1 -- openclaw.config.json
```

---

## 附录：配置 Schema 完整定义

### openclaw.plugin.json

```json
{
  "id": "openclawwechat",
  "name": "OpenClawWeChat",
  "description": "OpenClawWeChat - WeChat MiniProgram channel plugin for OpenClaw",
  "version": "1.1.0",
  "type": "module",
  "main": "index.ts",
  "author": "OpenClaw Plugin Development",
  "license": "MIT",
  "configSchema": {
    "type": "object",
    "additionalProperties": false,
    "properties": {
      "config": {
        "type": "object",
        "description": "单账户配置（兼容旧版本）",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "API Key（格式：bot_id:secret）"
          },
          "pollIntervalMs": {
            "type": "number",
            "default": 2000,
            "minimum": 500,
            "maximum": 60000
          },
          "sessionKey": {
            "type": "string",
            "default": "agent:main:main",
            "description": "Session Key（默认值）"
          },
          "sessionKeyPrefix": {
            "type": "string",
            "description": "[已弃用，请用 sessionKey] 兼容旧配置"
          },
          "debug": {
            "type": "boolean",
            "default": false
          }
        }
      },
      "accounts": {
        "type": "object",
        "description": "多账户配置",
        "additionalProperties": {
          "type": "object",
          "properties": {
            "apiKey": {
              "type": "string",
              "description": "该账户的 API Key"
            },
            "sessionKey": {
              "type": "string",
              "description": "该账户的 Session Key（非 default 账户必填）"
            },
            "pollIntervalMs": {
              "type": "number",
              "default": 2000,
              "minimum": 500,
              "maximum": 60000
            },
            "debug": {
              "type": "boolean",
              "default": false
            },
            "enabled": {
              "type": "boolean",
              "default": true,
              "description": "是否启用该账户；false 时禁用（渐进回滚用）"
            }
          },
          "required": ["apiKey"]
        }
      },
      "defaults": {
        "type": "object",
        "description": "多账户模式下的默认值",
        "properties": {
          "pollIntervalMs": {
            "type": "number",
            "default": 2000,
            "minimum": 500,
            "maximum": 60000
          },
          "debug": {
            "type": "boolean",
            "default": false
          }
        }
      }
    }
  }
}
```

### TypeScript 类型定义

```typescript
/**
 * 完整的插件配置类型
 */
export interface FullPluginConfig {
  // 单账户配置（兼容）
  config?: {
    apiKey?: string;
    pollIntervalMs?: number;
    sessionKey?: string;
    sessionKeyPrefix?: string;
    debug?: boolean;
  };

  // 多账户配置
  accounts?: {
    [accountId: string]: AccountConfig;
  };

  // 多账户默认值
  defaults?: {
    pollIntervalMs?: number;
    debug?: boolean;
  };
}

/**
 * 单个账户配置
 */
export interface AccountConfig {
  apiKey: string;
  sessionKey?: string;
  pollIntervalMs?: number;
  debug?: boolean;
  enabled?: boolean;  // 默认 true，false 时禁用
}

/**
 * 轮询账户配置（运行时）
 */
export interface PollingAccountConfig {
  accountId: string;
  apiKey: string;
  sessionKey: string;
  pollIntervalMs: number;
  debug: boolean;
  enabled: boolean;  // 默认 true
}
```

---

## 版本更新说明

### 从 v1.0.12 升级到 v1.1.0

**变更内容**：

1. **新增多账户支持**
   - 支持 `accounts` 配置对象
   - 支持 `defaults` 默认值对象
   - 每个账户独立配置

2. **向后兼容**
   - 保留 `config` 字段支持
   - 保留 `sessionKeyPrefix` 兼容性
   - 单账户配置无需修改

3. **新增字段**
   - `accounts.<id>.enabled`：启用标记（默认 true，false 时禁用）
   - `defaults.pollIntervalMs`、`defaults.debug`：默认值

4. **行为变更**
   - `listAccountIds()` 现在返回动态账户列表
   - `resolveAccount()` 现在支持从 `accounts` 解析
   - 轮询服务支持多账户并发

**迁移指南**：

1. **单账户用户**：无需操作，自动兼容
2. **多账户用户**：按照"多账户配置示例"修改配置
3. **测试验证**：参考"测试场景"章节

---

## 故障排查

### 常见问题

**Q1: 配置后没有看到多个账户轮询**

**A1**: 检查以下几点：
1. 配置格式是否正确（JSON 语法）
2. `accounts` 对象是否包含至少一个条目
3. 插件是否重新加载了配置
4. 查看日志是否有配置错误

**Q2: 某个账户一直失败**

**A2**: 检查以下几点：
1. 该账户的 apiKey 是否有效
2. sessionKey 配置是否正确且唯一
3. 后端是否支持该 apiKey（检查 api_keys 表）
4. 查看日志中的具体错误类型

**Q3: 两个账户的 Session 混在一起**

**A3**: 检查以下几点：
1. 两个账户的 sessionKey 是否不同
2. 检查日志中注入消息时的 sessionKey 值
3. 确认 runtime.channel.session 的存储路径配置

**Q4: offset 不生效，重复获取消息**

**A4**: 检查以下几点：
1. offset 是否正确更新（查看日志）
2. markProcessed 是否成功调用
3. 后端是否支持按 apiKey 分离消息队列
4. offset 持久化是否工作（如果启用）

**Q5: 回复消息发送到错误的账户**

**A5**: 检查以下几点：
1. 消息上下文中是否保存了 accountId
2. reply-sender 是否正确解析了目标账户
3. runtime.channel.session 的上下文管理是否正常

### 调试命令

```bash
# 查看当前配置
cat openclaw.config.json | jq '.plugins.entries.openclawwechat'

# 查看轮询日志
tail -f openclaw.log | grep "Polling"

# 查看账户状态
tail -f openclaw.log | grep -E "Starting|Stopping|Account"

# 统计每个账户的消息数
tail -f openclaw.log | grep "Injecting" | awk '{print $NF}' | sort | uniq -c
```
